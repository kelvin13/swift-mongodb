import MongoWire
import NIOCore

extension Mongo
{
    public 
    actor Cluster
    {
        private 
        let group:any EventLoopGroup,
            dns:DNS.Connection?
        private
        let settings:ConnectionSettings

        /// A list of currently open connections.
        private 
        var pool:ConnectionPool

        /// The minimum observed wire version among this clusterâ€™s nodes. 
        /// This is [`nil`]() until the first node has been contacted.
        public private(set) 
        var version:MongoWire?

        private 
        var sessions:SessionPool
        private 
        var hosts:Hosts

        private 
        init(settings:ConnectionSettings, hosts:[Mongo.Host],
            group:any EventLoopGroup,
            dns:DNS.Connection?) 
        {
            self.version = nil

            self.sessions = .init()
            self.hosts = .init(hosts)
            self.pool = .init()

            self.settings = settings
            self.group = group
            self.dns = dns
        }

        deinit
        {
            self.pool.removeAll()
            // TODO: end sessions
        }
    }
}
extension Mongo.Cluster
{
    public 
    init(settings:Mongo.ConnectionSettings,
        discovery:Mongo.Discovery,
        group:any EventLoopGroup) async throws 
    {
        switch discovery
        {
        case .standard(servers: let servers):
            try await self.init(settings: settings, servers: servers, group: group)
        
        case .seeded(srv: _, nameserver: nil):
            fatalError("unimplemented")
        
        case .seeded(srv: _, nameserver: _?):
            fatalError("unimplemented")
        }
    }
    public 
    init(settings:Mongo.ConnectionSettings, servers:[Mongo.Host],
        group:any EventLoopGroup) async throws 
    {
        assert(!servers.isEmpty)

        self.init(settings: settings, hosts: servers,
            group: group,
            dns: nil)
        
        _ = try await self.connection(to: .master)
    }

    public nonisolated
    func session(
        for command:(some MongoImplicitSessionCommand).Type) async throws -> Mongo.Session
    {
        try await self.session(on: command.node)
    }
    /// Attempts to obtain a connection to a cluster member matching the given
    /// instance selector, and if successful, generates and attaches a ``Session/ID``
    /// to it that the driver believes is not currently in use.
    ///
    /// Starting a MongoDB session involves no communication with the server;
    /// clients and servers simply use the session identifiers as a means of
    /// organizing operations.
    ///
    /// Because the session identifier is random and generated locally, there
    /// is a (small) chance that it may collide with a session identifier
    /// generated by a previous application run, if the application exited
    /// abnormally. UUID collisions are exceedingly rare, and the driver always
    /// attempts to clear sessions it generated on shutdown, so this is an
    /// extremely unlikely scenario.
    ///
    /// The driver will attempt to re-use session identifiers that are no
    /// longer in use if it believes the server has not yet released the
    /// session descriptor on its end, to minimize the number of active server
    /// sessions at a given time.
    public nonisolated
    func session(on instance:Mongo.InstanceSelector) async throws -> Mongo.Session
    {
        let connection:Mongo.Connection = try await self.connection(to: instance)
        return .init(connection: connection, manager: await .init(cluster: self))
    }

    func startSession() -> Mongo.Session.ID
    {
        self.sessions.checkout()
    }
    func extendSession(_ session:Mongo.Session.ID, timeout:ContinuousClock.Instant)
    {
        self.sessions.extend(session, timeout: timeout)
    }
    func releaseSession(_ session:Mongo.Session.ID)
    {
        self.sessions.checkin(session)
    }
}
extension Mongo.Cluster
{
    /// Obtains a connection to a cluster member matching the given instance selector.
    func connection(to selector:Mongo.InstanceSelector) async throws -> Mongo.Connection
    {
        // look for existing connections
        for (_, connection):(Mongo.Host, Mongo.Connection) in self.pool.connections
            where selector ~= connection.instance
        {
            return connection
        }
        // form new connections
        var errors:[(host:Mongo.Host, error:any Error)] = []
        while let host:Mongo.Host = self.hosts.checkout()
        {
            let connection:Mongo.Connection
            do
            {
                connection = try await self.connect(to: host)
            }
            catch let error
            {
                errors.append((host, error))
                self.hosts.blacklist(host)
                continue
            }
            if selector ~= connection.instance
            {
                return connection
            }
        }
        throw Mongo.ConnectivityError.init(selector: selector, errors: errors)
    }
    private 
    func connect(to host:Mongo.Host) async throws -> Mongo.Connection 
    {
        let connection:Mongo.Connection = try await .connect(to: host,
            settings: self.settings,
            resolver: self.dns,
            group: group)
        
        self.register(connection, to: host)
        
        connection.closeFuture.whenComplete 
        { 
            [weak self, host] _ in

            if let cluster:Mongo.Cluster = self 
            { 
                Task.init
                {
                    await cluster.unregister(connectionTo: host)
                }
            }
        }
        
        return connection
    }
    private
    func register(_ connection:Mongo.Connection, to host:Mongo.Host)
    {
        let instance:Mongo.Instance = connection.instance
        /// Ensures we default to the cluster's lowest version
        if  let version:MongoWire = self.version
        {
            self.version = min(instance.wireVersions.upperBound, version)
        } 
        else 
        {
            self.version =     instance.wireVersions.upperBound
        }

        self.pool.add(host: host, connection: connection)
        
        if let set:Mongo.Instance.ReplicaSet = instance.set
        {
            for host:Mongo.Host in [set.hosts, set.passives].joined() 
            {
                self.hosts.update(with: host)
            }
        }
    }
    private
    func unregister(connectionTo host:Mongo.Host)
    {
        self.pool.remove(host: host)
        self.hosts.checkin(host)
    }
}

extension Mongo.Cluster
{
    /// Runs a session command against the ``Mongo/Database/.admin`` database,
    /// sending the command to an appropriate cluster member for its type.
    public nonisolated
    func run<Command>(command:Command) async throws -> Command.Response
        where Command:MongoImplicitSessionCommand
    {    
        try await self.session(for: Command.self).run(command: command)
    }
    /// Runs a session command against the specified database,
    /// sending the command to an appropriate cluster member for its type.
    public nonisolated
    func run<Command>(command:Command, 
        against database:Mongo.Database) async throws -> Command.Response
        where Command:MongoImplicitSessionCommand & MongoDatabaseCommand
    {    
        try await self.session(for: Command.self).run(command: command,
            against: database)
    }
}
